# Project Plan: LiveTS

Our goal is to create a modern, performant, and developer-friendly library for building real-time, server-rendered web applications with TypeScript, inspired by Phoenix LiveView and Blazor Server.

### Guiding Principles

1.  **TypeScript First API:** Developers interact with a clean, fully-typed TypeScript API. All components, state, and event logic are written in TS.
2.  **High-Performance Rust Core:** The underlying engine is built in Rust for elite speed, memory safety, and concurrency, exposed to the Node.js runtime as a native addon.
3.  **Minimal Client-Side JS:** The client is a thin, generic host. All application logic lives on the server.
4.  **Declarative, HTML-centric Syntax:** Component logic and event handling are declared directly in the HTML, inspired by Alpine.js.
5.  **Tailwind CSS as a First-Class Citizen:** The framework is designed to work seamlessly with Tailwind CSS.
6.  **Cross-Runtime Compatibility:** Aims to run on Node.js, Deno, and Bun by abstracting the core engine.

---

### Core Architecture: The Hybrid Model

LiveTS will be built as a hybrid package. This gives us the best of both worlds: maximum performance and a fantastic developer experience.

- **The Engine (Rust):** A native module, compiled from Rust, handles all heavy lifting: WebSocket connection management, state storage, the event loop, and the high-speed HTML diffing/patching algorithm. We will use a tool like **NAPI-RS** to create a native Node.js addon.
- **The Public API (TypeScript):** A developer-friendly TypeScript wrapper that exposes the Rust engine's power. Developers will only ever need to write TypeScript; the Rust core is an implementation detail that makes the library incredibly fast.

---

### Phase 1: The Core Connection & State Management

This phase is about establishing the "heartbeat" of the framework, powered by the Rust core.

- **1.1: Server Setup & Initial Render**
  - Choose a lightweight server framework. **Hono** is a great choice for its speed, simplicity, and ability to run anywhere.
  - The server will perform the _first_ render of a component into static HTML and inject it into the page body.
- **1.2: WebSocket Handshake & Management (Rust Core)**
  - The Rust engine will handle the WebSocket lifecycle using a high-performance library like **`tungstenite`**. It will manage all connections and associate each with a specific LiveView instance in memory.
  - The client-side script will connect to this Rust-managed WebSocket endpoint.

#### **1.2.1: Detailed Rust WebSocket Architecture**

To achieve maximum performance and control, the Rust core will implement a specialized WebSocket broker tailored for LiveTS.

- **Technology Stack**:
  - **`tokio-tungstenite`**: We will use this for its tight integration with the `tokio` async runtime, which is the standard for high-concurrency applications in Rust. This provides non-blocking I/O for handling thousands of simultaneous connections efficiently.
  - **`dashmap`**: For managing the state of all active connections, we'll use `DashMap`. It's a highly concurrent hash map that allows for lock-free reads and sharded writes, minimizing contention as we look up, add, or remove connections.

- **Connection Management**:
  - A central `ConnectionManager` struct in Rust will hold a `DashMap<SessionID, Arc<LiveSocket>>`.
    - `SessionID`: A unique `uuid` generated for each new WebSocket connection.
    - `LiveSocket`: A Rust struct representing a single client connection. It will contain:
      - The "sink" half of the WebSocket connection for sending messages to the client.
      - A reference or ID pointing to the corresponding `LiveView` component instance being managed in the TypeScript layer.
      - A "heartbeat" tracker to detect and prune dead connections.

- **Optimized Message Handling Protocol**:
  - Instead of verbose JSON for every message, we will design a compact binary protocol or a highly structured JSON format using `serde` for serialization/deserialization.
  - **Client-to-Server**: Events will be encoded efficiently. For example, `[EVENT_TYPE_ID, EVENT_NAME, PAYLOAD]`. `EVENT_TYPE_ID` would be a single byte representing "click", "submit", etc.
  - **Server-to-Client**: DOM patches generated by the Rust differ will be sent in a compact binary format, avoiding the overhead of sending large HTML strings.

- **Lifecycle & Concurrency Model**:
  1. **HTTP Upgrade**: The initial request comes to the Hono server. Hono will identify it as a WebSocket upgrade request and hand it off to the Rust N-API module.
  2. **Connection Task**: The Rust module accepts the connection. For each new client, it will spawn a dedicated, lightweight `tokio` task. This isolates the read/write loop for each client, preventing a slow or buggy client from blocking others.
  3. **Registration**: The new connection task generates a `SessionID`, creates a `LiveSocket` struct, and registers it in the global `ConnectionManager`'s `DashMap`. It then calls back into TypeScript to instantiate the corresponding `LiveView` component.
  4. **Event Loop**: The task enters a loop, listening for incoming messages. When a message arrives, it's decoded and dispatched to the appropriate `LiveView` handler in TypeScript without blocking the listener task.
  5. **Cleanup**: If the connection is closed or the heartbeat fails, the task will trigger the `unmount` lifecycle hook in TypeScript and remove its `LiveSocket` entry from the `ConnectionManager`, ensuring no memory leaks.

- **1.3: Server-Side Component Model (TypeScript API)**
  - Define a `LiveView` base class in TypeScript.
  - It needs a `mount()` method to initialize state (`this.state = { count: 0 }`).
  - It needs a `render()` method that returns an HTML string.
  - These user-defined TS classes will be managed by the Rust core.
- **1.4: Client-Side Connector**
  - Write a small, generic JavaScript file (`connector.js`).
  - Its only jobs are:
    1.  Connect to the WebSocket.
    2.  Listen for messages (HTML patches) from the server.
    3.  Apply those patches to the current DOM.

**_Outcome of Phase 1: A browser loads a page, a WebSocket connects to the Rust engine, and a server-side component's state is held in memory, all orchestrated via a TypeScript API._**

---

### Phase 2: Rendering & DOM Patching

This is the "magic," now made hyper-efficient by Rust.

- **2.1: Implement the Diffing Algorithm (Rust Core)**
  - Instead of using a JavaScript library, we will implement a highly efficient HTML diffing algorithm directly in Rust. This will be a key performance advantage.
  - This Rust function will take two HTML strings ("old" and "new") and produce a compact set of patching instructions.
- **2.2: Implement the Diff & Patch Flow**
  - When a component's state changes, the TypeScript `render()` method is called.
  - The resulting HTML string is passed to the Rust engine's diffing function.
  - The Rust engine sends the compact patch set to the client over the WebSocket.
  - The client-side `connector.js` receives the patch instructions and applies them to the DOM. We can still use a minimal library like **`morphdom`** on the client if it simplifies applying patches, or handle it with vanilla JS.

**_Outcome of Phase 2: When a component's state changes, the UI updates almost instantly, thanks to a server-side diffing process written in Rust._**

---

### Phase 3: Interactivity & Events (Alpine.js Syntax)

This phase closes the loop, with the Rust core acting as the central event router.

- **3.1: Define Event Bindings**
  - Create special `ts-` prefixed attributes to declare interactivity directly in the HTML.
  - **Events:** `ts-on:click="increment"`, `ts-on:submit.prevent="save_form"`
  - **Data Binding:** `ts-model="form.username"`
  - **Content/Attribute Binding:** `ts-text="user.name"`, `ts-class="{ 'bg-red-500': has_error }"`
  - **Conditionals:** `ts-if="is_logged_in"`
- **3.2: Client-Side Event Delegation**
  - The `connector.js` captures user interactions and sends a standardized event message to the server (e.g., `{ type: 'click', event: 'increment' }`).
- **3.3: Server-Side Event Handling (Rust Core -> TypeScript API)**
  - The Rust engine receives the event message from the WebSocket.
  - It looks up the correct `LiveView` instance and calls the `handleEvent()` method on the user's TypeScript component, passing the event details.
  - After the user's TypeScript logic runs and updates the state, the Rust engine automatically triggers the re-render and diffing flow from Phase 2.

**_Outcome of Phase 3: A seamless interactive loop where user events are efficiently routed through the Rust core to the developer's TypeScript logic and back to the UI._**

---

### Phase 4: Polish & Advanced Features

This phase turns our library into a robust framework that's a pleasure to use.

- **4.1: Component Lifecycle**
  - Add more lifecycle hooks to the `LiveView` class: `updated()`, `unmount()`.
- **4.2: Forms & Validation**
  - Integrate a library like **`zod`** for defining validation schemas in the TypeScript layer.
- **4.3: Pub/Sub for Real-Time Sync (Rust Core)**
  - Implement a high-performance Pub/Sub system directly in the Rust core. This will be far more efficient than a JavaScript-based solution.
- **4.4: Developer Experience & Tooling**
  - Create a simple CLI tool (`create-livets-app`) to scaffold a new project.
  - **The scaffolder will automatically set up Tailwind CSS** and handle the installation of the correct native addon (`.node` file) for the user's platform.
